# 信息的表示和处理

现代计算机存储的信息都以二进制形式。信息决定计算机要做什么（指令），以及表示和处理各种数字、字符串等

为什么要用二进制来表示？由计算机的电气实现所决定——信号很容易存储在双稳态单元中

本章重点讨论三种：无符号整数，补码，浮点数。

# 信息存储

以字节为最小单位，1byte = 8 bit

从十进制看，范围是0 - 255

从二进制看，范围是 0 - 11111111

从16进制看，范围是0 - 0xFF

## 字数据大小

每台计算机都有一个字长的属性，即指针数据的标称大小（虚拟地址宽度），十多年前，大部分的计算机字长都是32位，限制了地址空间为4GiB （2 ^ 32byte），64位字长目前已成为主流，寻址能力达到了18EiB（2 ^ 64byte）

64位机器兼容32位的程序，反过来不行。一个.c文件可以被编译为64位程序，也可以编译为32位程序。

```bash
linux> gcc -m32 prog.c  #编译为32位程序
linux> gcc -m64 prog.c #编译为64位程序
```

下表是C语言中的各数据类型位宽，他们或是小于字长，或大于字长，但都是字节的整数倍。

| C语言数据类型 | 典型32位系统 | 典型64位系统 | x86-64 |
| ------------- | ------------ | ------------ | ------ |
| char          | 1  byte      | 1            | 1      |
| short         | 2            | 2            | 2      |
| int           | 4            | 4            | 4      |
| long          | 4            | 8            | 8      |
| float         | 4            | 4            | 4      |
| double        | 8            | 8            | 8      |
| long  double  | −            | −            | 10/16  |
| pointer       | 4            | 8            | 8      |

32位机器正确运行的程序不一定在64位机器上也正常。例如32位机器中，用`int`来存储指针，但是这在64位机器是禁止的。

## 寻址和字节序

对于跨越多字节的对象，我们必须确立两个事项：

- 这个对象的地址是什么
- 在内存中如何排列这些字节

在几乎所有的机器上，多字节对象都被存储为**连续**的字节序列，对象的地址为所使用字节中最小的地址。

排列方式有两种：

小端序（Little endian）: Intel 

低地址存放低位数据，高地址存放高位数据

大端序（Big endian）: IBM, Sun Microsystem（Oracle）

低地址存放高位数据，高地址存放低位数据

例如：0x1234567

<img src="https://frun1na.netlify.app//20250118224254.png" style="zoom:50%;" />

注：使用哪一种没有技术上的差别。

**探索数据在存储器中的存储方式**

<img src="https://frun1na.netlify.app/20250118225212.png" style="zoom:67%;" />

这段代码用于打印各变量的字节表示形式，show_bytes函数用于绕开C语言中的类型系统，其他的数据类型也可以使用类似的方法探索

执行下列代码：

```c
void test_show_bytes (int val) {
    int ival = val;
    float fval = (float)ival;
    int *pval = &ival;

    show_int(ival);
    show_float(fval);
    show_pointer(pval);
}
```

得到如下结果：

![](https://frun1na.netlify.app/20250118225410.png)

## 表示字符串

C语言的字符串使用char数组表示

每个字符都被编码成ASCII码

一个7比特的字符编码集 （扩展集为8比特）

字符“0” 的编码是0x30

数字字符 i 的编码是 0x30 +i

字符串的结尾应为空字符，即ASCII编码为0

字符串的表示与字节序无关，大端小端都兼容

<img src="https://frun1na.netlify.app//20250118230540.png" style="zoom:50%;" />

从低地址到高地址，其中00为高地址。

## 表示代码

不同类型的机器使用不同的且**不兼容**的指令和指令编码

在相同处理器不同的操作系统中，由于编码规范存在差异，同样代码所生成的程序也不是二进制兼容的

程序很少能够在不同类型机器和不同操作系统中实现二进制水平上移植（直接移植可执行文件不太行，但移植.c代码可能行）

![](https://frun1na.netlify.app/20250118231419.png)

这串代码编译后得到如下二进制代码：

```assembly
Linux 32   55 89 e5 8b 45 Oc 0345 08 c9 c3
Windows    55 89 e5 8b 45 0c 0345 08 5d c3
Sun        81 c3 eO 08 90 02 00 09
Linux 64   55 48 89 e5 89 7d fc 89 75 f8 0345 fc c9 c3
```

Windows操作系统下常用的可执行文件格式是PE

Unix家族（含Linux）操作系统下可执行文件格式为ELF

## 布尔代数简介

由19世纪数学家乔治·布尔发明

逻辑的代数表示方法：“真”编码为1，“假”编码为0

<img src="https://frun1na.netlify.app/20250118232419.png" style="zoom:50%;" />

**比特向量的布尔代数运算**

对于一串二进制数，进行逻辑运算是一位一位的。

<img src="https://frun1na.netlify.app/20250118232546.png" style="zoom:50%;" />

## C语言中的位运算

四个运算符

**|**  for Or （位或）

**&** for And （位与）

**~**  for Not（位非）

**^**  for eXclusive-Or （位异或）

**异或运算的应用：数据交换**

```c
void funny(int *x, int *y) {
    *x = *x ^ *y; 
    *y = *x ^ *y; 
    *x = *x ^ *y; 
}
```

<img src="https://frun1na.netlify.app/20250118232936.png" style="zoom:50%;" />

这样的数据交换不额外使用变量

## C语言中的逻辑运算

定义了三种逻辑运算

**||** （logical or,逻辑或）

**&&**（logical and,逻辑与）

**!**（logical not, 逻辑非）

**短路效应**

1.  X && 5/X 可以用于避免除0运算

2.  p && *p++ 可以避免空指针运算

3.  5 || X=Y 赋值语句将不会被执行

## C语言中的移位运算

左移：<<

a << k

a的二进制表示中，丢掉最高的k位，补上最低k个0，即左移k位。

右移： >>

​	逻辑移位和算术移位

​	右移运算有逻辑移位（左侧补0）和算术移位（左侧补原最高位值）两种操作

​	C语言标准中并没有详细地定义编译器具体应使用哪一种右移运算

​	对于无符号数，右移一定是逻辑的

​	对于有符号数，理论上编译器采用逻辑右移和算术右移都是符合规范的

​	在实践中，几乎所有的编译器针对有符号数的右移都采用的是算术右移，大多数程序员也将这种情况视为默认

<img src="https://frun1na.netlify.app/20250118234050.png" style="zoom: 67%;" />

**小知识：未定义行为**

C语言规范中没有被明确定义的行为称为未定义行为

编程时应避免使用未定义行为，有符号数算术右移除外

例如，使用位移运算符移动k位，但是k大于原来的数据位数w

`int aval = 0x0EDCBA98 >> 36;`

32位`int`右移36位，实际上gcc只会右移36 mod 32 即 4 位。但这在不同编译器是不一样的。

# 整数表示

在本节中，我们介绍用位来编码整数的方式，一种只能表示非负数，另一种可以表示负数，0，正数。

下面是用到的一些术语：

<img src="https://frun1na.netlify.app/20250119183754.png" style="zoom:50%;" />

下面是c语言支持的整数数据类型以及每种类型的范围：

![](https://frun1na.netlify.app//20250119212833.png)

为什么负数的范围比正数要大一？

## 无符号数的编码

假设一个整数数据类型有*w*位，其二进制编码可以用一个位向量x来表示
$$
\vec{x} =(x_{w-1}, x_{w-2,} x_{w-3,}... ,x_{0} )
$$
$$\vec{x} =(x_{w-1}, x_{w-2,} x_{w-3,}... ,x_{0} )$$

于是，将二进制的编码转为无符号数：
$$
B2U_{w}(\vec{x})=\sum_{i=0}^{w-1}x_{i}\cdot 2^{i}
$$
$$B2U_{w}(\vec{x})=\sum_{i=0}^{w-1}x_{i}\cdot 2^{i}$$

例如：

![](https://frun1na.netlify.app/20250119220232.png)

无符号数与其二进制编码是一一对应的。

## 补码编码

对于许多应用，我们还希望表示负数。最常见的有符号数的表示方式就是补码。

在这个定义中，将最高有效位解释为负权

<img src="https://frun1na.netlify.app//20250119222859.png" style="zoom:33%;" />

例如：

![](https://frun1na.netlify.app//20250119223225.png)

与无符号数相同，在编码可表示的范围内，每个整数和其补码是一一对应的。

如下图是一些重要的数字及其编码：

![](https://frun1na.netlify.app//20250119223724.png)

我们注意到

2*TMax + 1 = UMax

-1和UMax对应的相同的二进制编码

一般来说，c语言实现有符号数都是使用的补码编码。

在c语言标准库中有一个`<limits.h>` 定义了一组常量：`INT_MAX`、` INT_MIN` 、 `UINT_MAX`对应了表中的TMax、TMin、UMax

有符号数还有其他表示方法，例如反码和原码，详见教材P47。

**常见的无符号数有符号数编码**

等价性：有符号数和无符号数的非负值编码相同

唯一性

​	每个编码都表示唯一的整数值

​	每整数有唯一的编码

可以反向映射

**将整数转换为补码**

如果该数字值非负 ，补码等于该值对应的二进制数（位长不足补0）

否则 ，其绝对值的二进制数逐位取反，并加1，符号位置1

举例：假设某个整数类型位长为4

-5

绝对值的二进制： 101

逐位取反：010

加一，且符号位置一：1011

## 有符号和无符号转换

### **有符号数转无符号数**

C语言允许将有符号数转换为无符号数

转换结果：二进制编码本身没有发生变化

非负数没有发生变化

负数转换为一个（大）正数

​	假设二进制有w位，那么有符号数x就是-2^(w-1)+后面，因此，转为无符号要在原有符号数的基础上加上两倍的最高位对应数字，即x+2^w

将一个有符号转为无符号相当于两步：先将有符号转为二进制，再把二进制转为无符号。

即T2U(x) = B2U(T2B(x))

![](https://frun1na.netlify.app/20250121190507.png)

### **无符号数转有符号数**

相当于先将无符号转为二进制，再将二进制转为有符号

<img src="https://frun1na.netlify.app/20250121191207.png" style="zoom:50%;" />

## C语言中的有符号数与无符号数

常量：缺省情况下，所有的整数常量都是有符号数，如果需要声明无符号数常量，需要增加一个后缀 “U”

例如：`123U`，`123u`，`0x123U`，`0x123u`

变量：可以进行显示转换和隐式转换。

例如：

```c
int x = 123;
int ux = (unsigned)x;
unsigned int uy;
int y = (int)uy; //显示转换

int x;
unsigned int ux;
ux = x; //隐式转换
```

表达式求值：如果在一个表达式中混用无符号数和有符号数，有符号数会先被隐式转换成无符号数，然后再求值。

这对一些算数表达式没有什么影响，但是<>这样的关系表达式有很大影响。

![](https://frun1na.netlify.app/20250121193405.png)

## 位扩展

将一个字长小的数转换为字长大的数，即对该数进行位扩展，并保证扩展后的值不变。

无符号数：零扩展，即扩展后最高位的空位补0

有符号数：符号位扩展，即扩展后最高位的空位原编码的符号位

<img src="https://frun1na.netlify.app/20250123225146.png" style="zoom:50%;" />

注：从一个数据大小到另一个数据大小的转换，以及无符号和有符号数字之间的转换的相对顺序能够影响一个程序的行为。例如：

```c
short x = 12345;
unsigned int ux = x;
```

当把short转换成unsigned时，先扩展位，然后转为无符号。即`(unsigned) x`等价于`(unsigned)(int) x`而不是另一个顺序。这是C语言的标准。

## 截断数字

如果我们减少表示一个数字的位数

```c
int   x  = 53191;
short sx = (short) x;
int   y  = sx;
```

那么：

![](https://frun1na.netlify.app/20250123230107.png)

**多余的高位直接被丢弃**。

具体证明过程在P57页。

## 关于有符号数与无符号数的建议

什么时候使用有符号，什么时候使用无符号？

不能仅因为参数值非负就使用无符号数

很容易导致逻辑错误

有些错误很难发现

例如：

```c
unsigned i;
for (i = cnt-2; i >= 0; i --)
    a[i] += a[i-1]
```

当在某一次循环时，i=0，然后i再减一，由于i为无符号，减一发生下溢，即-1转换为无符号时，为最大的无符号数值，导致循环次数错误。对于有符号数，最小的有符号数-1，发生下溢，也会变成最大的有符号数。

与之相对的是上溢，即最大是无符号数再加上1，就会变成0。最大的有符号数+1会变成最小的有符号数。

例2：

```c
/* stdio.h */
typedef unsigned int  size_t;
/* Prototype library function strlen */
size_t strlen(const char *s);
int strlonger(char *s, char *t) {
    return strlen(s) – strlen(t) > 0;
}
```

如果s长为0，那么0-t，发生下溢，返回true.

例3:

```c
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;

    for (i = 0; i <= length-1; i++)
        result += a[i];
    return result;
}
```

如果length = 0，那么在i > length时，发生访问出界

例4：

<img src="https://frun1na.netlify.app//20250123232928.png" style="zoom: 67%;" />

如果maxlen = -1，那么len转化为非常大的无符号数，然后程序就将这么多的字节数据从内核复制到缓冲区(正常情况最大复制KSIZE个字节)，导致安全问题，因为正常情况下不可能访问到这么多的内核代码。

这个问题是由于在一个地方，长度为有符号，另一个地方，长度为无符号，这样的类型不匹配导致的。

要消除这个问题，只要将maxlen声明为size_t，同时将len也声明为size_t即可。

**何时使用无符号**？

把字仅仅看做是位的集合而没有任何数字意义时。例如，位向量。unsigned int 表示32位的一个向量，每个位都是bool类型的，0表示存在，1表示不存在。

掩码

地址 （内存地址、网络地址），这自然就是无符号的

高精度计算：数字是由字的数组来表示的，无符号值也会非常有用

# 整数运算

整数加法

4比特的两个整数 u、v

Add4(u, v)函数用来计算数学上的和

计算结果随着u和v的增长呈现线性的变化

在图像上形成了一个平面

![](https://frun1na.netlify.app/20250124222646.png)

我们以4bit为例，那么0 <= u，v <= 15，那么0 <= u+v <= 30，要表示30，至少要5bit，这导致了“字长膨胀”

两个数，加来加去，字长会无限增长。例如Lisp，允许任意字长的高精度运算(前提是在内存允许范围内)

## 无符号数加法

接下来，我们定义**无符号的整数加法**

![](https://frun1na.netlify.app/20250124223346.png)

这种定义将u+v截断为w位，作为u+v的结果，即u+v mod 2^w，按照另一种理解，我们也可以认为，这是忽略了进位的那个位

![](https://frun1na.netlify.app/20250125171238.png)

### **无符号数加法的图形表示**

![](https://frun1na.netlify.app/20250125171357.png)

![](https://frun1na.netlify.app/20250125171424.png)

当真实值大于2^w时，出现截断。

### **检测无符号整数加法的溢出**

对于s = x + y，其中0 <= x , y <= UMax，s为x，y无符号加法的结果，那么当且仅当s < x(或者s < y)时，发生溢出。证明见书P62

### 阿贝尔群

这种无符号数的加法形成了**阿贝尔群**

具有封闭的加法运算  0 <= UAdd*w*(*u* , *v*)  <= 2^*w* –1

交换律

结合律

具有唯一的0元素

每个元素都有补元素  

​	对于每个值x，存在-x使得x + (-x) = 0

无符号数求反：

![](https://frun1na.netlify.app/20250125175326.png)

## 有符号数加法

TAdd(u,v)=U2T ( UAdd(T2U(u), T2U(v)) )

相当于先把u,v转为无符号，然后无符号相加，得到的结果转为有符号。

最小值和最大值需要用w+1位来表示，因此需要截断。

![](https://frun1na.netlify.app/20250125183618.png)

如果太大，就会减。如果太小，就会加。

### 有符号数加法的图形表示

![](https://frun1na.netlify.app/20250125184121.png)

### 有符号数加法溢出问题讨论

*s* = TAdd*w*(*u* , *v*)

如果u,v > 0且s < 0那么发生了正溢出

如果u,v < 0且s > 0那么发生了负溢出

如果s == u + v没有溢出

## 有符号数的相反数

对满足表示范围的有符号数，该数的相反数为

![](https://frun1na.netlify.app/20250125191245.png)

在C语言中，有~x + 1 = -x，即~x + x = -1

![](https://frun1na.netlify.app/20250125191449.png)

## 无符号乘法

计算两个w位宽整数在数学上的乘积

无符号数：0 ≤ x * y ≤ (2w – 1) ^2 = 2^(2w) – 2^(w+1) + 1

这需要2w位来表示。但是在c语言中，会被截断为w位。

![](https://frun1na.netlify.app//20250125211844.png)

![](https://frun1na.netlify.app/20250125212756.png)

## 有符号数乘法

二进制表示和无符号相同

![](https://frun1na.netlify.app/20250125213102.png)

分别将有符号操作数转为无符号，然后使用无符号相乘，然后转为有符号。

有符号数和无符号数乘法使用**相同**的机器指令进行运算

## 乘以常数

在大多数机器上，整数乘法指令相当慢，其他整数运算（例如加法、减法、位级运算和移位）很快。

编译器使用 了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。

首先，我们考虑乘以2的幂的情况

u << k 等价于 u * 2 ^ k

同时适用于有符号数和无符号数

![](https://frun1na.netlify.app/20250125221344.png)

那么，如何表示乘以常数？

以x * 13为例，14 = 2^3 + 2^2 +  2^0

那么，原式 = x << 3 + x << 2 + x << 0或者x << 4 - x << 2 + x << 1 - x << 0;

假设乘以常数K

将K写为01序列，即[(0...0)(1...1)(0...0)...(1...1)]

对于每个连续的1的子序列(假设从n到m位，其中n >= m，且最低位从0开始)，我们通过两种方式计算乘积：

- x << n + x << (n-1) + x << (n-2) +...+x << m
- x << (n + 1) - x << m

然后，将所有的连续的1的子序列求乘积后的值都相加，得到总的x * K

## 除以2的幂

在大多数机器上，整数除法要比整数乘法更慢

除以2的幂也可以用移位运算来实现，只不过我们用的是右移

**无符号数**和**有符号数**分别使用**逻辑移位**和**算术移位**来达到目的

向下取整指对于a，与a最近的两个整数b <= a <= c，得到值为整数b。例如3.14 -> 3，-3.14 -> -4

向上取整同理。得到c

那么，一个数u >> k表示的是u / (2^k)向下取整。对于无符号，没有问题。

<img src="https://frun1na.netlify.app//20250125224027.png" style="zoom:50%;" />

但是对于有符号，当u<0时，**会发生取整方向的错误**。

![](https://frun1na.netlify.app/20250125224226.png)

我们需要的是向着0方向舍入。例如，对于-71.2我们希望舍为-71

如何修正这一结果？

在小于0的时候，只要加上2^k - 1，再右移即可，即(x + (1 << k) - 1) >> k

证明见教材P73

遗憾的是，这种办法**不能**推广到除以任意常数

## 总结

计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种既能表示负数也能表示正数的方法，同时使用了与执行无符号算术相同的二进制实现

我们特别看到了unsigned数据类型，虽然它概念上很简单，但可能导致即使是资深程序员都意想不到的行为。

# 浮点数

采用 v=x×2^y 的方式

有理数的近似表示

在v的绝对值在远大于1或者远小于0时，这种方法具有不错的性能

对于程序员，这种方法无趣且难以理解

## 小数的二进制表示

理解浮点数的第一步是考虑含有小数值的二进制数字。

先看一个十进制的小数：

dm , dm-1 , dm-2, ... d1, d0, d-1, d-2, ...d-n

那么，这个数字表示的数值就是每一位上的数字乘以他们对应的权值，然后都相加

他们的权值都是10的整数幂

类似的，对于小数的二进制表示，每个位的权值都是2的幂

<img src="https://frun1na.netlify.app/20250126192408.png" style="zoom:67%;" />

每个位取值范围时0，1

然后同样的将每个位的值乘以对应权值再相加，即为小数的二进制表示

乘2除以2可以通过左移与右移实现

0.1111111...表示非常接近1的数

假定我们只考虑有限位长

那么，这种表示方法是有误差的

增加位长可以增加表示的精度

## 发展历史

在1980年以前，存在着许多特殊的编码格式

IEEE 754 规范

​	1985年建立了统一浮点数运算统一标准

​	主流处理器都支持

编码在设计上充分的考虑的数字表示的问题

优雅的处理了取整, 上溢出和下溢出的问题

编码能够尽最大限度的发挥硬件的运算性能

在标准定义时，数值分析人员相比硬件设计人员占据更多的主导地位

## IEEE浮点数的编码

### 数字的表示形式

![](https://frun1na.netlify.app//20250126202309.png)

符号位 s ：决定了数字的正负

尾数 M：一个小数，取值为[1.0,2.0) 或 [0.0, 1.0)

阶码 E：2的E次幂

### 编码方式

最高位是符号位 s

exp 编码后得到 E （exp不等于e）

frac 编码后得到 M （frac不等于M）

![](https://frun1na.netlify.app/20250126202421.png)

### 几种精度的浮点数

单精度：32位

![](https://frun1na.netlify.app//20250126202621.png)

双精度：64位

![](https://frun1na.netlify.app//20250126202654.png)

扩展精度：80位（仅Intel支持）

![](https://frun1na.netlify.app//20250126202719.png)

### IEEE 754标准

根据exp的值，被编码的值可以分成三种不同的情况

规格化，非规格化，特殊值(两个)

#### 规格化数

![](https://frun1na.netlify.app/20250126230013.png)

当exp的位既不全为0(数值0)，也不全为1

**阶码**的值是E = Exp - Bias

其中

​	Exp为exp域的无符号整数值

​	Bias = 2^(k-1) - 1，k为exp的位宽

​		对于单精度，k = 8，Bias = 127

​		对于双精度，k = 11，Bias = 1023

frac域的值表示小数，范围是0 <= frac < 1

**尾数**M = frac + 1，即包含一个隐式的前缀1（M = 1.xxxxxxx），这是二进制的小数表示

对于一个浮点数，我们总是可以调节阶码E，使得1 <= M < 2，因此，前缀1是总是存在的，那就没必要显示的表示，可以节省一个bit

#### 举例：规格化数编码

float f = 15213.0

首先将其10进制转为2进制：11101101101101 = 1.1101101101101 * 2 ^ (13)

因此E = 13，Bias = 127

因此exp = 13 + 127 = 140 = 10001100

M = 1.1101101101101，则frac = 1101101101101

结果：

![](https://frun1na.netlify.app/20250127002025.png)

#### 非规格化数

当阶码域为全0时

阶码 E = 1 - Bias

尾数 M = frac

为什么这样表示？

提供了一种表示数值0的方法，因为使用规格化数，总是使M >= 1

实际上，当符号位为0，其他位全是0表示的是+0.0，符号位为1，其他全为0，表示的是-0.0。在某些方面被认为是不同的（例如极限计算，可以区分从哪个方向趋于0），而在其他方面是相同的

非规格化数的另外一个功能是表示那些非常接近于0.0的数。它们提供了一种属性， 称为逐渐溢出（gradual underflow) 其中，可能的数值分布均勻地接近于0.0，而不是直接下溢成0

#### 特殊值

当指阶码全为1，当frac域全为0时，得到的值表示无穷，根据符号位确定+/-

当frac域为非零时，结果值被称为“NaN(Not a Number)”不是一个数，表示数值无法确定。例如根号-1，无穷减去无穷，无穷乘以零等。

#### 浮点编码的可视表示

![](https://frun1na.netlify.app/20250127004703.png)

### 举例：一个微型的浮点数编码系统

8位浮点数编码

最高位为符号位

接下来是4位exp，偏置Bias为7

最后3位是frac

与IEEE规范具有相同的形式

![](https://frun1na.netlify.app/20250127004931.png)

![](https://frun1na.netlify.app/20250127004951.png)

可以观察到最大非规格数7/512和最小的规格化数8/512的平滑转变。

**需要关注的数字**

![](https://frun1na.netlify.app/20250127005508.png)

### 特殊属性

假如把浮点数解释为无符号整数，那么这些浮点数的大小关系，相对位置不变。通过这种特点，我们可以使用整数的排序算法对浮点数排序

不过要注意首先比较符号位，负数是从大到小，而正数从小到大。

练习把一些整数值转换成浮点形式对理解浮点表示很有用

## 运算

### 舍入

浮点数都是4舍，6入的，但是**对于5的情况**，是舍还是入？

向下舍入

​	舍入结果接近但不会大于实际结果

向上舍入

​	舍入结果接近但不会小于实际结果

向 0 舍入

​	舍入结果向 0 的方向靠近

​	如果为正数，舍入结果不大于实际结果

​	如果为负数，舍入结果不小于实际结果

#### 向偶数舍入

浮点数运算默认的舍入模式

其他的舍入模式都会统计偏差，如果都是5舍，那这一组数估计就是偏低，如果都5入，就偏高。这种方式由于偶数和奇数概率上相等，因此，在总误差上就会抵消。

适用于舍入至小数点后任何位置

当数字正好处在四舍五入的中间时

向最低位为偶数的方向舍入

![](https://frun1na.netlify.app/20250127102735.png)

#### 二进制数的向偶数舍入方法

偶数方向意味着舍入后最后一位为 0

中间意味着**待舍入**的部分为 100…

例如，我们舍入到值最近的四分之一，也就是保留两位小数。

10.00011待舍入部分为011，这要舍去，因为小于100

10.0011待舍入部分为110，这要入，因为大于100

10.111待舍入为100，判断奇偶，入后最后一位是0，因此要入，变成11.00

10.101待舍入为100，舍后最后一位为0，因此要舍，变成10.10

### 浮点运算

IEEE 标准指定了一个简单的规则，首先计算出精确的值，然后舍入，得到结果。

在实际中，浮点单元避免执行精确计算，只要精确到能够保证得到一个正确的舍人结果。

当参数中有一个是特殊值，IEEE标准进行了一些定义，例如1/-0 = 负无穷等。

如果阶码值过大，可能会导致溢出

#### 浮点数加法

![](https://frun1na.netlify.app/20250127115758.png)

精确的结果

​	符号位与尾数M：有符号数对齐相加

​	阶码E：E2

![](https://frun1na.netlify.app/20250127120055.png)

注：一定要根据阶码对齐再相加

修正

​	如果M >= 2，右移M，并增大E的值

​	如果M < 1，将M左移k位，E减去k

​	如果E超出范围，溢出

​	对M进行舍入，以满足frac宽度

浮点数加法与阿贝尔群相似，有交换性，但是**没有结合性**，具体看教材P85

表达式(3.14 + 1e10) - 1e10得到0.0

但是 3.14 + (1e10 - 1e10)得到3.14

对于任何数，加上NaN得到NaN

浮点数加法满足单调性：a >= b，那么对于任意a,b,x，有x + a >= x + b，无符号或有符号整数的加法没有这个性质。

#### 浮点数乘法

![](https://frun1na.netlify.app/20250127120947.png)

精确的结果 

符号位S: s1与s2计算

尾数M：M1 * M2

阶码E：E1 + E2

修正

​	同加法，只不过M不可能小于1

没有结合性，分配性

满足单调性

详见教材P86

### C语言中的浮点数

C语言标准中支持两种精度的浮点数

​	float     单精度

​	double   双精度

类型转换

​	在 int、float和double间进行类型转换会改变编码（与有/无符号整数转换不同）

double/float → int

​	截断尾数部分

​	向0舍入

​	标准中没有定义越界和NaN的情况：通常是设置为TMin和TMax

int/float → double

​	精确转换，由于int的位宽小于53

int → float

​	将会浮点数舍入模式进行舍入

double → float

​	可能会溢出

![](https://frun1na.netlify.app/20250127134242.png)

为什么

 "0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1+ 0.1 "≠ 1

 "0.2 + 0.2 + 0.2 + 0.2 + 0.2 = 1"

因为准度和精度问题

