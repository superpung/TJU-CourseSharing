# 程序的机器级表示

# 基础知识

## 历史观点

Intel x86系列处理器

在笔记本、桌面和服务器市场占有统治低位

向后兼容至8086处理器（诞生于1978年）

随着时间增加了许多新的特性

复杂指令集计算机（CISC）

​		指令多、指令格式复杂

​		在Linux程序中只使用其中一个子集

理论上CISC的性能很难与精简指令集计算机（RISC）相匹敌

但是Intel采用了CISC

在低功耗情况下，速度会有影响

现在RISC又兴起。

### Intel x86系列的进化

![](https://frun1na.netlify.app/20250127161145.png)

Transistors：晶体管

### Intel x86系列处理器

新特性的加入

多媒体操作的指令支持

提供了更加有效率的条件操作指令

机器字长从32位变为64位

多核

### 摩尔定律

单位面积上可以容纳的晶体管数量几乎每两年增加一倍

![](https://frun1na.netlify.app/20250127161406.png)

### X86兼容处理器：AMD

历史上

​	AMD仅仅跟随着Intel

​	性能稍差，价格更**便宜**

随后

​	从DEC和其他业绩下降的公司招聘顶级电路设计师

​	提出了Opteron架构：成为Pentium 4的有力竞争对手

​	引入了x86-64架构，自主的扩展到64位体系结构

近年来

​	Intel重新迎头赶上，重新占据了半导体技术的世界主导地位

​	AMD稍有落后，依赖外部的半导体代工厂

### Intel 64位处理器曲折的发展历史

2001年：Intel试图从IA32彻底转变为IA64

​	性能令人失望

2003年：AMD提出了体系结构进化的解决方案

​	x86-64位体系结构（现称为AMD64）

​	Intel觉得有应该专注于发展IA64

​	不承认技术路线的失误，不认可AMD方案更优

2004年：Intel提出了EM64T体系结构实现对IA32的64位扩展

​	几乎与x86-64相同

2019年：英特尔宣布放弃IA64架构

除低端x86处理器外，其他处理器均支持x86-64

但是目前许多程序仍然在32位模式下运行

## C，汇编和机器语言

### 定义

**体系结构：**（指令集体系结构，ISA）编写汇编代码时需要理解的处理器设计部分。

定义硬件与软件的接口，软件以什么样的格式来操作硬件完成相应动作。

​	例如：指令集规范、寄存器组织

**微体系结构：**体系结构的**具体实现**

这样的接口如何实现？

​	例如：高速缓存大小、核心频率

机器语言：处理器可以直接执行的**字节级**的程序（bit流）

汇编语言：**文本形式**的机器语言（机器语言的注解）

举例：常见的指令集体系结构

Intel: x86, IA32, Itanium, x86-64

ARM：几乎所有的移动电话中都使用

### C和汇编语言的不同

高级语言

​	更抽象，因此生产力更高，不易出错

​	一条高级语言可以转换为多条汇编语言，因此更抽象

​	大多数高级语言都有类型检查，防止出错

​	编译器设计很复杂，高级语言通过编译，可以转化为**非常高效**的机器语言。

​	跨平台能力

汇编语言

​	手动内存管理，需要很大精力

​	复杂运算通过简单的指令完成，因此很复杂

​	不同平台的汇编语言不同

​	汇编语言只有**整数和浮点数**，没有数据类型的概念

#### 汇编数据类型

**整数：**1、2、4或8字节的

​	可能是数据的值

​	也可能是地址 （无类型的指针）

**浮点数：**4、8或10字节

**代码：**指令的字节序列编码

**没有聚合类型**，例如：数组或结构体

这些在汇编语言中都都表现为在内存中连续分配的字节

这些内存如何使用，完全由汇编语言程序员**手动管理**。

#### 汇编运算

对**寄存器**或存储器数据执行算术/逻辑运算

​	在寄存器和存储器间传输数据

​	将数据从存储器加载至寄存器

​	将寄存器的数据存储至存储器

转移控制

​	无条件跳转 / 过程调用

​	条件分支

### 汇编语言视角

![](https://frun1na.netlify.app/20250127165458.png)

cpu中

​	寄存器：速度很快，使用频率最高，最靠近运算器，存储即将送入运算器的数据

​	条件码：存储最近一次算术逻辑运算的状态信息(进位，符号位等)，用于条件分支

​	PC寄存器（程序计数器）：存储下一条要执行指令的地址，x86-64中的名称为RIP

存储器(内存)

​	基于字节寻址的数组

​	存储程序和用户数据

​	存储栈数据（以实现过程的支持）

​	手动管理

### C转换为机器指令

通过一个例子学习

代码文件：p1.c p2.c

编译命令：`gcc –Og p1.c p2.c -o p`

使用基本的编译优化选项 `–Og `（最新版本GCC支持）或者-o1

将编译结果写入文件 **p**

-o表示编译后，自定义输出的文件名称，p为具体名称

以下为得到可执行文件的步骤：

![](https://frun1na.netlify.app/20250127170812.png)

通过编译将.c转化为.S汇编文件，然后通过汇编器转化为可重定向目标文件.o(二进制文件)，链接器将.o和静态库.a链接，生成可执行文件

![](https://frun1na.netlify.app/20250127171214.png)

使用下面的命令生成

`gcc –Og –S sum.c`

生成文件：**sum.s**

注：由于编译器版本不同，目标平台不同，优化不同，可能生成的汇编指令不同。

例如，malloc,printf是C库函数，在链接时期完成后才能正确调用。

除此以外，还有动态库的链接

### 举例：机器指令

<img src="https://frun1na.netlify.app//20250127171657.png" style="zoom:50%;" />

c语言中的执行单位：语句

汇编语言的执行单位：指令

C：将 **t** 的值存储至 **dest** 指向的地址

汇编

​	将8字节的数据（在x86-64中称为四字）移动至存储器

​	rax寄存器的数据放到rbx所指的地址中

机器指令

​	存储于地址 0x40059e

​	3字节的指令

### 反汇编目标码

机器指令可以使用相关工具进行反汇编

反汇编器

`objdump –d sum`指令，sum是一个可执行文件，也可以是.o

linux系统中

将机器指令还原为汇编指令

探索目标码的一个十分有用的工具

gdb也可以对程序反汇编

```bash
gdb sum  #使用gdb对sum调试，进入gdb界面
x/14xb sumstore #从sumstore开始14字节进行反汇编
```

反编译出汇编语言不代表理解了这个程序的行为，因为难以理解，并且对于大型程序，也几乎不可读。

### GCC汇编代码

GCC产生的汇编代码中.S有很多比较难读

![](https://frun1na.netlify.app/20250127174058.png)

在这个文件中，所有以.开头的行都没有用

他们是指示汇编器和链接器工作的指令。

# 基本操作

## 汇编语言格式

![](https://frun1na.netlify.app/20250127221905.png)

本课程使用ATT格式的汇编代码。

标号

​	一个可选的内容，用于说明指令的所在位置。用于跳转指令

​	地址的注记符

操作码

​	必选的

​	指令的注记符，用于表示什么指令

操作数

​	0个1个2个

​	用逗号分割

​	操作数1为源操作数，操作数2为目标操作数



另一种格式：英特尔汇编，结构相同，最大的区别是两个操作数是反的。

除此以外，内存寻址也有区别。

教材P118详细介绍了两种方式的区别

GCC默认采用ATT汇编

## x86寄存器

### x86-64寄存器

![](https://frun1na.netlify.app/20250127223225.png)

x86-64有16个寄存器，每个存放8字节数据

每个寄存器的低32位可以使用特殊的别名直接访问

### IA32(x86-32)寄存器

8个通用寄存器

![](https://frun1na.netlify.app/20250127223628.png)

每个32位，低16位有别名，提供对低位的直接访问。

尤其是abcd三个寄存器，也有别名

注：x86-64兼容IA32，因此在x86-64中也可以通过IA32的方式来访问。

注：所有的SP寄存器用于存放栈顶指针，在IA32寄存器中BP寄存器也有特殊作用，存放堆顶指针，但是在x86-64中，BP已经失去了其特殊作用。

## 数据移动指令

源操作数复制到目标操作数，源操作数的数不变。

`movq Source ,Dest`

### 操作数类型

​	**立即数：**整数常量

​		例如： $0x400, $-533

​		和C语言中的常数类似，但需要加前缀 **$**

​		被编码为1、2、4或8个字节

​	**寄存器：**十六个整数寄存器之一

​		例如： %rax, %r13

​		%rsp有特殊用途，通常不使用

​		其他寄存器在一些特殊的指令中也会有特殊用途

​	**存储器：**指向的内存中8个连续字节，由寄存器给出地址

​		一个简单的例子：(%rax)

​		有很多其他的“寻址模式”

### 操作数的组合

固定的组合关系

![](https://frun1na.netlify.app/20250127224610.png)

立即数不能是目标操作数，不能给常量赋值

源操作数是Mem，目标操作数只能是Reg不能是Mem，不支持直接将内存的一个数复制到另一个内存。

冯诺依曼体系中，所有指令通过CPU完成，需要处理器参与。不能绕过处理器，需要处理器作为媒介，先从内存加载到寄存器，再从寄存器加载到内存。

### 数据格式

操作码的后缀

![](https://frun1na.netlify.app/20250127225612.png)

根据后缀决定了访问多少个字节

### 举例

```c
void swap (long *xp, long *yp) 
{
  long t0 = *xp;
  long t1 = *yp;
  *xp = t1;
  *yp = t0;
}
```

```assembly
swap:
   movq    (%rdi), %rax
   movq    (%rsi), %rdx
   movq    %rdx, (%rdi)
   movq    %rax, (%rsi)
   ret
```

cpu执行swap需要5条指令。

首先，函数的参数存在rdi与rsi中

![](https://frun1na.netlify.app/20250127230016.png)

这两个寄存器中存放的是地址，指向内存的两个区域

临时变量存在哪个寄存器由编译器分配。

![](https://frun1na.netlify.app/20250127230219.png)

一定要自己分析一下整个过程。

### 内存寻址

完整的存储器寻址模式

一般使用四元组形式寻址。

![](https://frun1na.netlify.app/20250127230836.png)

​	S只能是1，2，4，8因为基本数据类型只能是这些字节。

​	可以用于**数组元素**寻址，进行地址计算。

​	偏移量D可以对**结构体**的支持很好。

特例，一些元素可以缺省。

![](https://frun1na.netlify.app/20250127231004.png)

D缺省表示0

S缺省表示1

Rb/Ri缺省表示该寄存器为0

## 算术、逻辑运算指令

### 地址计算指令

`leaq Src, Dst`

​	Src是寻址模式表达式

​	将表达式计算的地址写入Dst

用途

​	计算地址（计算过程中不需要引用存储器）例如`p = &x[i]`

​	计算模式为 x + k*y 的表达式 （普通的算术运算）k = 1,2,4,8

```c
long m12(long x)
{
  return x*12;
}
```

编译后的汇编指令

```assembly
leaq (%rdi,%rdi,2), %rax     # x存在rdi中，相当于将3x存到rax
salq $2, %rax                # return t<<2
```

lea不会对内存进行任何访问

salq为左移指令

这两条指令的执行速度比只有一条乘法快得多

虽然lea是用作地址计算的，由于其不访存的特点，也用于算数运算

### 一些常见算术指令

#### 两操作数指令

​	（双目运算）

注意操作数的顺序

有符号数和无符号数指令没有区别（为什么？）

​	加法减法不论有无符号，在二进制位级别上相同，乘法也一样

​	除法分为有无符号两种。

![](https://frun1na.netlify.app/20250128102001.png)

右移有逻辑算数之分，为了对称，设计的左移指令也有逻辑和算数，不过行为上没有任何区别

`salq`算数左移

`shlq`逻辑左移

#### 单操作数指令

（单目运算）

更多的指令介绍见教材

<img src="https://frun1na.netlify.app/20250128104756.png" style="zoom:67%;" />

### 举例

#### 算数运算示例

![](https://frun1na.netlify.app/20250128105531.png)

![](https://frun1na.netlify.app/20250128105552.png)

我们来分析这段代码

t1 = x + y使用的lea指令来计算，为什么不用更常见的add？

​	对于add，要把其中一个操作数覆盖掉。但是这里的x,y 都要继续参与运算，不能被覆盖，因此还要用mov先保存一下。使用lea就**直接**把结果存在另一个寄存器，这是编译器设计很好的地方。

第二条将z + t1存在t2中

​	直接使用add很合理，因为t1已经不用了，可以直接覆盖掉。这体现了编译器对寄存器使用的非常合理

然后通过两条指令替换掉乘法指令。高级语言1条语句可能对应2条汇编

下面蓝色内容，汇编语言1条指令可能对应高级语言2条语句。

两个变量相乘没有其他办法，只能使用耗时的乘法

汇编语言**固定使用rax保存返回值**。

结论：

指令顺序和C语言语句顺序不同

一些表达式需要由多条指令组合实现

一些指令可以实现多个表达式的功能

(x+y+z) * (x+4+48 * y)可以得到相同的汇编代码，不要以为使用这一条语句就是对程序优化，实际上得到相同的汇编代码

临时变量不一定需要用内存，编译器足够聪明，优先使用寄存器保存变量

#### 逻辑运算举例

![](https://frun1na.netlify.app/20250128111204.png)

值得注意的是，mask计算过程没有在汇编语言中体现。

因为mask是常量计算的结果，编译器在编译阶段计算，得到8185常量，在下一条语句使用。

**常量之间运算**在编译阶段完成

使用andl32位指令可以得到64位计算的结果

​	mask是一个long型64位，(1 << 13) - 7结果本身为32有符号，赋给long，进行位扩展，正数，因此高位是0，与运算与0得0，因此使用64位与运算，那么结果的高32位是0。又由于对64位寄存器用低32位的引用，自动清零高32位，因此得到相同结果。

# 控制

## 条件码

处理器的工作状态

​	所有对于程序员可见的寄存器和标志位

![](https://frun1na.netlify.app/20250128130405.png)

临时数据

​	( %rax, … )等寄存器

运行时栈的位置（栈顶）

​	( %rsp )

当前代码控制点的位置（即将要执行的指令地址）

​	( %rip, … )

最近一次指令执行的状态

​	标志寄存器，不能通过汇编语言直接访问

​	间接修改和访问

​	每个位都有含义，最重要的CF，ZF，SF，OF（又叫条件码）

### 详细介绍

**位寄存器**

CF   Carry Flag (for unsigned) 

​     进位标志（无符号数）

​	无符号数发生溢出时，即发生进位或者借位时，该位置1

SF   Sign Flag (for signed)

​     符号标志（有符号数）

​	运算结果非负，置0，负数，置1

ZF    Zero Flag

​     零标志

​	运算结果为0，置1

OF   Overflow Flag (for signed)

​     溢出标志（有符号数）

​	对于有符号数是溢出，而不是进位

​	溢出时置1

有两种方法设置标志位，分别是隐式和显示

### 设置条件码

#### 隐式设置

通过算术运算可以隐式设置条件码（可以把它看做是运算的副作用）

例如： addq Src,Dest ↔ t = a+b

**CF** 被置位，如果运算时出现了超出最高位的进位（无符号数运算溢出）

**ZF** 被置位，如果 t == 0

**SF** 被置位，如果 t<0 （看做是有符号数）

**OF** 被置位，如果有符号数运算出现了溢出

`(a>0 && b>0 && t<0) || (a<0 && b<0 && t>=0)`a,b大于0，结果小于零，或者相反时置OF

汇编语言无法确定有符号或者无符号数

在计算时**同时看作**有符号和无符号

​	看作有符号，设置SF,OF

​	看作无符号，设置CF

​	这两件事同时干。

**注：lea地址运算指令不会修改条件码**

#### 显式设置

汇编语言有专门的指令修改条件码

这些指令运算不会修改操作数，仅仅修改条件码

##### 比较指令

使用**比较指令**可以显式设置条件码

`cmpq Src2, Src1`

cmpq b,a 这条指令和a-b的作用类似，但不需要将结果写入目标寄存器

**CF** 被置位，如果运算时出现了超出最高位的借位（用于无符号数比较）

**ZF** 被置位，如果 a == b

**SF** 被置位，如果 (a-b) < 0 （看做是有符号数）

**OF** 被置位，如果有符号数运算出现了溢出

`(a>0 && b<0 && (a-b)<0) || (a<0 && b>0 && (a-b)>0)`

##### 测试指令

使用**测试指令**也可以显式设置条件码

`testq Src2, Src1`

testq b,a 这条指令和a&b的作用类似，但不需要将结果写入目标寄存器

根据 Src1&Src2 的结果设置条件码

用于对一个操作数的某几个位进行掩码检测

**ZF** 被置位，当 a&b == 0

**SF** 被置位，如果 (a&b) < 0

与运算不会发生进位和溢出

例如，查看a的最低位是否为1，那么写一个b = 000000...00001

test b, a

如果ZF == 1，那么a的最低位不为1

可以进行更多位的同时检测

### 访问条件码

set指令族间接访问

SetX指令

根据条件码表达式将**目标寄存器**的最后一个字节修改为0或1

不会影响目标寄存器最高7个字节的值

![](https://frun1na.netlify.app/20250128134544.png)

### x86-64寄存器的最后一个字节

![](https://frun1na.netlify.app/20250128135121.png)

别名

### 例子

![](https://frun1na.netlify.app/20250128135301.png)

在x86-64指令集中，32位操作指令会将目标寄存器的高32位清0

al寄存器如果大于，置1，否则置0。高7byte无影响

由于返回值为int，因此要将高24位填充为0

movzbl z表示0，b表示从byte开始扩展，l表示扩展到4byte（0扩展，从8bit到32bit）

​	同时由于是32位指令，又同时对高32位置0。最后rax的高63位都为0

**注：（8位指令操作，高位不影响，32位指令操作，高位置0）**

## 条件分支

### 跳转指令

jX指令

根据条件码跳转到代码的其他位置执行

![](https://frun1na.netlify.app/20250128140411.png)

### 跳转指令编码

首先是如下汇编程序

![](https://frun1na.netlify.app/20250128141225.png)

有两个跳转，一个无条件，一个有条件

将其编译为可执行文件，然后反汇编得到如下片段：

![](https://frun1na.netlify.app/20250128141353.png)

跳转指令在编码的时候，对于跳转目标采用**相对编码**

所以eb 03中的03描述的是**偏移量**。在执行jmp指令时，eip的值为4004d5（下一条指令）

在jmp指令中，改变eip的值，加上3。计算出真正的跳转的绝对地址。

jg同理。注：偏移量为**补码**编码

如果跳转的距离过大，那么还有其他编码格式的更大范围的跳转指令用于选择。选择哪个跳转由编译器决定

为什么使用相对偏移量？更灵活。不论分配到哪个地址，都可以运行。

### 跳转实现分支结构

#### 早期

使用条件跳转实现分支

生成汇编代码

`gcc –Og -S –fno-if-conversion control.c`

-og表示不改变程序原有结构的优化。工业常用-o1/-o2优化程度更高，更看不懂

–fno-if-conversion表示不要把分支语句优化为数据传输形式，而是条件跳转

现在编译器默认优化为数据传输，所以要加这个选项

![](https://frun1na.netlify.app/20250128143242.png)

清晰的看到，使用条件跳转实现分支。

使用goto语句写出示例程序的等价表示：

```c
long absdiff_j (long x, long y)
{
    long result;
    int ntest = x <= y;
    if (ntest)
        goto Else;
    result = x-y;
    goto Done;
 Else:
    result = y-x;
 Done:
    return result;
}
```

结论：对于简单的if-else，先判断是否不满足，如果不满足，跳转到else。如果满足，顺序执行。

在c中还有一种表示分支的情况，就是三目运算符

如果使用条件跳转语句实现，结果同上。

#### 现在

使用**条件数据传输**实现分支

可以认为是条件赋值

指令的功能：       

​	if (Test) Dest `->` Src

​	根据条件码决定是否将源操作数赋值到目标操作数

​	与mov相似，额外条件判断

1995年后的x86处理器开始支持

GCC在编译时会尝试使用这个指令翻译条件分支

​	仅当保证逻辑安全的时候使用

​	有不适用的条件，后面讲

为什么使用条件数据移动指令？

​	分支会破坏**流水线**的指令流，影响处理器性能

​	条件数据移动指令不需要改变控制流

​	流水线可以对指令执行加速，非常可观，需要指令预取，通常顺序预取。跳转指令无法判断，无法预取，导致性能下降。第四章介绍。

```c
result = Then_Expr;
eval = Else_Expr;
nt = !Test;

if (nt) result = eval;  //仅需要1条指令即可实现

return result;
```

先计算出两种值，判断，决定赋值哪个。

宏观上是顺序执行，没有跳转

虽然会增加两种result的计算，但是由于流水线的优化性能更高级，整体上更优

#### 举例：条件数据传输

![](https://frun1na.netlify.app/20250128220201.png)

![](https://frun1na.netlify.app/20250128220240.png)

其中，`cmovle`就是条件数据传输，其中le表示less or equal

#### 不适用条件

大量的计算

​	条件数据移动指令会将所有的结果提前计算出来

​	只有计算都**非常简单**的时候，使用条件数据移动指令才会有意义

`val = Test(x) ? Hard1(x) : Hard2(x);`

存在风险的计算

​	可能导致程序出错

​	`val = p ? *p : 0;`

​	p解引用必须要在p不为空的前提下操作

​	条件数据传输会在不考虑条件的情况下，算出两种结果。

有副作用的计算

​	`val = x > 0 ? x*=7 : x+=3;`

## 循环

给出c语言中对应的goto形式

这可以很容易知道循环在汇编语言上如何实现

### do-while

![](https://frun1na.netlify.app/20250128221554.png)

使用条件分支决定继续或退出循环

编译后的结果：

```c
	movl    $0, %eax		#  result = 0
.L2:				        # loop:
	movq    %rdi, %rdx	
    andl    $1, %edx		#  t = x & 0x1
    addq    %rdx, %rax		#  result += t
    shrq    %rdi		    #  x >>= 1
    jne     .L2		        #  if (x) goto loop
    rep; ret //组合指令，书P141旁注解释了rep
```

ne针对的是shrq的操作结果，看是否为0

传入无符号数，进行逻辑右移。

右移指令缺省，操作数默认为目标操作数，源操作数默认1

该程序的含义：计算x的二进制表示编码中的1的bit个数

rep为字符串操作指令，为什么在这里？如果rep不配合另一个字符串操作指令，就认为它是空指令。相当于在jne和ret之间插入一个空操作。这是编译器针对x86流水线的优化。连续两条跳转指令挨着，会影响x86流水线的性能。具体解释在第四章。

![](https://frun1na.netlify.app/20250128222933.png)

了解到goto版本，就了解到do-while怎么翻译为汇编指令了。

### while

与do-while相比，第一次就要判断循环条件是否成立

有两种翻译方式

#### 跳转到中间

“跳转到中间”翻译方法

使用 –Og 编译优化选项生成代码

![](https://frun1na.netlify.app/20250128224529.png)

多了一个跳转，用于第一次条件判断

除此以外，和do-while相同。

##### 举例

![](https://frun1na.netlify.app/20250128224803.png)

需要连续两次跳转，导致性能下降

#### 翻译2

使用 –O1 编译优化选项生成代码

![](https://frun1na.netlify.app/20250128224931.png)

好处：第一次判断，满足条件直接进入，不用两次跳转

空间：插入更复杂的代码，占用额外空间

##### 举例

![](https://frun1na.netlify.app/20250128225140.png)

### for

#### 一般形式

包括：初始化，检测，更新，循环体

#### 改造

for -> while -> do-while -> goto

![](https://frun1na.netlify.app/20250128230626.png)

#### 举例

![](https://frun1na.netlify.app/20250128230949.png)

在这个例子中，wsize为常量

i的初值0为常量

因此，初始的循环条件检查，在这个例子，可以被编译器优化‘

如果不是常量，就不能优化。

## switch语句

本质上，switch可以被条件分支等价表达

为什么还定义了switch？

C中switch的条件表达式结果必须要是整数，不接受其他结果。

机器级实现基于**跳转表**

### 跳转表

![](https://frun1na.netlify.app/20250128231725.png)

根据变量值，查跳转表对应元素，跳入对应代码块

与if-else-if相比，跳转到任何一个代码块都是**花费固定的时间**，优势很大

if-else-if如果要跳入最后一个块，必须要进行前面的判断。

变量必须要整数，作为查找表的下标，进行查表

### 机器级实现

...后续笔记不再更新

